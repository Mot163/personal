{"code":0,"message":"获取文章简要信息成功!","data":{"id":"6","title":"Java面向对象","description":"Java面向对象","cover":"","content":"## 1. 面向对象概述\n\n- 面向对象是软件开发的一种方法，它是相对于面向过程来讲的。面向过程就是将执行某件事的过程一步一步地列出来执行。而面向对象执行某件事时，只是让能执行这件事的某个对象去执行，而不关心怎么执行，但执行这件的对象最底层实际上还是像面向过程一样去执行。\n- 面向对象能处理比面向过程更复杂的问题。\n- 面向对象是对宏观的把控，从整体上合理分析，但最基本的东西还是要用面向过程处理。\n- Java的面向对象一般具有三大特性：<font color=red>封装</font>、<font color=red>继承</font>和<font color=red>多态</font>。\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 2. 类与对象的介绍\n\n- 类与对象就是面向过程的产物，它们用来描述宏观整体的事物\n- 类是一种抽象的数据类型，它用来对某一类事物进行整体的描述和定义，但不能代表这一类事物中的某一个具体的事物，只是这一类事物的共同特征(<font color=red>属性</font>和<font color=red>行为</font>)的抽象(模板)\n- 对象是与类相对的具体实例，它代表着一类事物中的一个具体事物\n\n- 例子：世界上有很多狗，狗是一个类，而你家的小狗旺财就是一个具体的对象\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 3. 类与对象的创建\n\n- 类使用class关键字创建\n- 类创建的格式：修饰符 class 类名 { [属性] [方法] }\n- 对象在类创建后使用new关键字创建\n- 对象的创建格式：类名 对象名 =  new 类名();\n\n```java\npublic class Dog {\t// 创建Dog类\n    \n    // 属性\n    String name;\n    int age;\n    \n    // 方法\n    public void say() {\n        System.out.println(\"汪汪汪~\");\n    }\n    \n    public static void main(String[] args) {\n        \n        // 实例化对象\n        Dog dog = new Dog();\n        \n        dog.say(); // 输出：汪汪汪~\n        \n    }\n    \n}\n```\n\n- 内存分析图示：\n\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200817165543199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbmdKaW5fbW8=,size_16,color_FFFFFF,t_70#pic_center)\n\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 4. 类的构造器\n\n- 构造器是实例化对象时所必须调用的一个方法，也称构造方法\n- 默认不写的情况下，Java会自动生成一个无参的构造器\n- <font color=red>构造器的名称必须和类名相同</font>\n- <font color=red>构造器没有返回类型，也不能写void</font>\n- <font color=red>创建带参构造器后，要显式地创建无参构造</font>\n\n- 创建构造器的格式：public 类名([参数]) {[方法体]}\n\n```java\npublic class Demo {\n    \n    public String str;\n    \n    // 创建带参构造器\n    public Demo(String str) {\n        this.str = str;\t// this表示当前对象\n    }\n    \n    // 创建无参构造器\n    public Demo() {}\n    \n    public static void main(String[] args) {\n        \n        // 实例化对象\n        Demo demo1 = new Demo();\n        Demo demo2 = new Demo(\"Hello!\");\n        \n        System.out.println(demo1.str);\n        System.out.println(demo2.str);\n        \n        System.out.println(\"结束\");\n        \n        /*\n         结果：\n         null\n         Hello!\n         结束\n         */\n        \n    }\n    \n}\n```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 5. 封装\n\n- 封装就是对数据的隐藏，程序设计一般追求“<font color=red>高内聚，低耦合</font>”，即内部的数据尽量内部处理，仅暴露少量的方法给外面使用\n- 一般将类的属性一般通过get/set方法进行封装，即将类的属性设为私有，让外面通过创建的公共方法get和set进行访问和设定\n\n```java\npublic class Demo {\n    \n    private String str;\t// 通过private将str属性设为私有\n    \n    //创建get方法提供属性的访问\n    public String getStr() {\n        return this.str;\n    }\n    \n    //创建set方法提供属性的设置\n\tpublic void setStr(String str) {\n        this.str = str;\n    }\n    \n    public static void main(String[] args) {\n        \n        // 实例化对象\n        Demo demo = new Demo();\n        //set方法设置str的值\n        demo.setStr(\"Hello!\");\n        //get方法获取str的值\n        String str = demo.getStr()\n        \n        System.out.println(str);\n        \n        System.out.println(\"结束\");\n        \n        /*\n         结果：\n         Hello!\n         结束\n         */\n        \n    }\n    \n}\n```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 6. 继承\n\n#### 6.1 认识继承\n\n- 继承是对一个类的扩展，若B类继承了A类，B类就拥有了A类所有非私有(用private修饰的)的属性和方法，其中A类被称为父类(基类)，B类被称为子类(派生类)\n- <font color=red>Java中的继承只有单继承，没有多继承</font>，即一个子类只能继承一个父类，但一个父类可以有多个子类\n- 继承使用关键字<font color=red>extends</font>，例如：class B <font color=red>extends</font> A {}\n- 被final关键字修饰的类不可被继承\n- 所有的类直接或间接继承Object类\n\n```java\nclass A {\n\n    public String str1 = \"str1\";\n    private String str2 = \"str2\";\n\n    public void printA() {\n        System.out.println(\"AAA\");\n    }\n\n}\n\nclass B extends A {\n\n}\n\npublic class Demo {\n\n    public static void main(String[] args) {\n\n        B b = new B();\n        System.out.println(b.str1);\n        // System.out.println(b.str2);  (str2为私有的，无法输出str2属性)\n        b.printA();\n\n        System.out.println(\"结束\");\n\n        /*\n         结果：\n         str1\n         AAA\n         结束\n         */\n\n    }\n\n}\n```\n\n\n\n#### 6.2 super()\n\n- super()给子类用来调用父类的构造方法\n- 默认不写的情况下，Java自动在子类的构造方法中生成\n- <font color=red>super()必须在子类构造方法的第一个</font>\n- <font color=red>super()只能出现在子类的构造方法中（不带括号”()“的spuer可以出现在其他的地方表示子类的父类对象）</font>\n- <font color=red>super()和this()不能同时调用构造方法（this()可以用来调用类本身的构造方法）</font>\n\n```java\nclass A {\n\n    public String str;\n\n    public A(String str) {\n        this.str = str;\n        System.out.println(\"调用A的带参构造方法\");\n    }\n\n    public A() {\n        System.out.println(\"调用A的空构造方法\");\n    }\n\n}\n\nclass B extends A {\n\n    public B(String str) {\n        super(str);\t// super()调用A类的构造方法\n        System.out.println(\"调用B的带参构造方法\");\n    }\n\n    public B() {\n        System.out.println(\"调用B的空构造方法\");\n    }\n\n}\n\npublic class Demo {\n\n    public static void main(String[] args) {\n\n        B b1 = new B();\n        B b2 = new B(\"Hello!\");\n\n        System.out.println(\"结束\");\n\n        /*\n         结果：\n         调用A的空构造方法\n         调用B的空构造方法\n         调用A的带参构造方法\n         调用B的带参构造方法\n         结束\n         */\n\n    }\n\n}\n```\n\n\n\n#### 6.3 方法重写\n\n- 方法重写是继承中的一个重要机制，它是之后实现多态的重要技术手段\n- 方法重写也称方法覆盖。当子类想对继承于父类的方法进行修改时，就可是使用方法重写将继承于父类的方法进行覆盖，而不必去动父类的方法\n- <font color=red>方法重写必须要有继承关系，而且是子类重写父类的方法</font>\n- <font color=red>方法重写的方法名必须相同</font>\n- <font color=red>方法重写的参数列表必须相同</font>\n- <font color=red>方法重写的修饰符范围可以扩大不能缩小（public>protected>default(默认不写)>private）</font>\n- <font color=red>方法重写的抛出异常范围可以缩小不能扩大</font>\n- 方法重写一般要在方法上面加上@Override注解\n- <font color=red>被final修饰符修饰的父类方法不能被重写</font>\n- <font color=red>重写被static修饰符修饰的父类方法时，该方法在子类中也需要用static修饰符修饰，并且不能在方法上面加上@Override注解</font>\n- <font color=red>方法重写和方法重载非常相似，但它们是不同的概念。方法重写是继承中的子类和父类的同名方法，而方法重载是一个类中的多个同名方法</font>\n\n```java\nclass A {\n\n    public void print() {\n        System.out.println(\"HelloA\");\n    }\n\n}\n\nclass B extends A {\n\n    @Override\n    public void print() {\n        System.out.println(\"HelloB\");\n    }\n    \n}\n\npublic class Demo {\n\n    public static void main(String[] args) {\n\n        A a = new A();\n        a.print();\n\n        B b = new B();\n        b.print();\n\n        System.out.println(\"结束\");\n\n        /*\n         结果：\n         HelloA\n         HelloB\n         结束\n         */\n\n    }\n\n}\n```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 7. 多态\n\n- 多态指同一个实体同时具有多种形式，而在Java中，这个实体一般就指的是父类类型的对象，即不同的父类类型的对象调用同样的方法会产生不同的结果\n- 多态是方法的多态，属性没有多态性\n- 多态存在的三个必要条件：\n  - 要有继承\n  - 要有方法的重写\n  - 父类引用指向子类（即在声明创建中，将实例化创建的子类对象赋予给父类类型声明的变量，格式：父类名 变量名 = new 子类名();）\n\n```java\nclass A {\n\n    public void print() {\n        System.out.println(\"HelloA\");\n    }\n\n}\n\nclass B extends A { // 1.继承\n\n    // 2.重写\n    @Override\n    public void print() {\n        System.out.println(\"HelloB\");\n    }\n\n}\n\nclass C extends A { // 1.继承\n\n    // 2.重写\n    @Override\n    public void print() {\n        System.out.println(\"HelloC\");\n    }\n\n}\n\npublic class Demo {\n\n    public static void main(String[] args) {\n\n        // 3.父类引用指向子类（上转型对象）\n        A a1 = new B();\n        a1.print();\n\n        A a2 = new C();\n        a2.print();\n\n        System.out.println(\"结束\");\n\n        /*\n         结果：\n         HelloB\n         HelloC\n         结束\n         */\n\n    }\n\n}\n```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 8. 类型转换与instanceof\n\n- 有继承关系(线性继承)的子类型对象和父类型对象可以进行类型转换，子类型转父类型为<font color=red>自动转换</font>，父类型转子类型为<font color=red>强制转换</font>\n- 两个类型不相关的对象不能进行类型转换\n- 类型转换可能会丢失一些方法，子类型转父类型可能会丢失子类特有的方法，而父类型转子类型也会也可能会丢失父类私有的方法\n- 强制转换格式：<font color=red>(要转换的类型名)对象名</font>\n- instanceof是用来判断是否能进行类型转换的二元运算符，其左边为实例对象名，右边为类名，返回值为一个布尔值true或false，格式：<font color=red>实例对象名 instanceof 类名</font>\n- instanceof通常用于进行类型转换前的的判断\n\n```java\nclass A {}\n\nclass B extends A {}\n\nclass C extends A {}\n\npublic class Demo {\n\n    public static void main(String[] args) {\n\n        /* **********类型转换********** */\n\n        B b = new B();\n        A a;\n        C c;\n\n        a = b;  // 自动转换\n        b = (B)a;  // 强制转换\n\n        a = new A();\n        // c = (C)b; 运行报错ClassCastException（强制类型转换异常）\n        // b = (B)a; 运行报错ClassCastException（强制类型转换异常）\n        \n\n        /* **********instanceof********** */\n\n        boolean flag;\n\n        B b1 = new B();\n        flag = b1 instanceof B;\n        System.out.println(\"B b1 = new B(); b1 instanceof B ==> \"+flag);\n        // flag = b instanceof C; 编译报错\n        flag = b1 instanceof A;\n        System.out.println(\"B b1 = new B(); b1 instanceof A ==> \"+flag);\n        flag = b1 instanceof Object;\n        System.out.println(\"B b1 = new B(); b1 instanceof Object ==> \"+flag);\n\n        System.out.println(\"--------------------------------\");\n\n        A a1 = new B();\n        flag = a1 instanceof B;\n        System.out.println(\"A a1 = new B(); a1 instanceof B ==> \"+flag);\n        flag = a1 instanceof C;\n        System.out.println(\"A a1 = new B(); a1 instanceof C ==> \"+flag);\n        flag = a1 instanceof A;\n        System.out.println(\"A a1 = new B(); a1 instanceof A ==> \"+flag);\n        flag = a1 instanceof Object;\n        System.out.println(\"A a1 = new B(); a1 instanceof Object ==> \"+flag);\n\n        System.out.println(\"--------------------------------\");\n\n        A a2 = new A();\n        flag = a2 instanceof B;\n        System.out.println(\"A a2 = new A(); a2 instanceof B ==> \"+flag);\n        flag = a2 instanceof C;\n        System.out.println(\"A a2 = new A(); a2 instanceof C ==> \"+flag);\n        flag = a2 instanceof A;\n        System.out.println(\"A a2 = new A(); a2 instanceof A ==> \"+flag);\n        flag = a2 instanceof Object;\n        System.out.println(\"A a2 = new A(); a2 instanceof Object ==> \"+flag);\n\n        System.out.println(\"结束\");\n\n        /*\n         结果：\n         B b = new B(); b instanceof B ==> true\n         B b = new B(); b instanceof A ==> true\n         B b = new B(); b instanceof Object ==> true\n         --------------------------------\n         A a = new B(); a instanceof B ==> true\n         A a = new B(); a instanceof C ==> false\n         A a = new B(); a instanceof A ==> true\n         A a = new B(); a instanceof Object ==> true\n         --------------------------------\n         A a2 = new A(); a2 instanceof B ==> false\n         A a2 = new A(); a2 instanceof C ==> false\n         A a2 = new A(); a2 instanceof A ==> true\n         A a2 = new A(); a2 instanceof Object ==> true\n         结束\n         */\n\n    }\n\n}\n```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 9. 抽象类\n\n- 抽象类是Java中一种特殊的类，当我们只知道类中需要哪些属性方法，却不知道某些方法具体如何实现时就可以写一个抽象类\n- 抽象类必须用<font color=red>abstract</font>关键字修饰，例如：abstract class Demo {...}\n- 抽象类不能被实例化，无法用new关键字来调用抽象类的构造器创建抽象类实例，但能声明\n- 如果一个类中有抽象方法（用<font color=red>abstract</font>修饰的方法），那么这个类必须声明成抽象类\n- 抽象类可以包含以下五部分：\n  - 成员变量（属性）\n  - 方法（普通方法或抽象方法）\n  - 构造器（不能用于创建实例，主要用于子类调用）\n  - 初始化块\n  - 内部类（接口、枚举）\n- 抽象类可以被继承，但继承了抽象类的类必须实现抽象类中的抽象方法，除非继承抽象类的类也是抽象类\n\n```java\n// 抽象类A\nabstract class A {\n\n    // 成员变量\n    String str;\n\n    // 构造器\n    public A(String str) {\n        this.str = str;\n    }\n\n    //抽象方法\n    public abstract void print();\n\n    //普通方法\n    public String getStr() {\n        return this.str;\n    }\n\n}\n\n// 普通类B继承抽象类A\nclass B extends A {\n\n    public B(String str) {\n        super(str);\n    }\n\n    @Override\n    public void print() {\n        System.out.println(\"Hello\");\n    }\n}\n\npublic class Demo {\n\n    public static void main(String[] args) {\n\n        // 实例化\n        // A a = new A(\"world\");  抽象类不能实例化，编译报错\n        A a = new B(\"world\");\n        a.print();\n        System.out.println(a.getStr());\n        \n        System.out.println(\"结束\");\n\n        /*\n         结果：\n         Hello\n         world\n         结束\n         */\n\n    }\n\n}\n```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 10. 接口\n\n- 接口是Java中的一种结构，它是一系列方法和属性的声明，是一种约束和规范\n- 接口用<font color=red>interface</font>进行声明，例如：public interface Demo {...}\n- 接口不能被实例化，但能声明\n- 一个类可以继承多个接口，继承接口用<font color=red>implements</font>关键字\n- 接口中的属性默认用<font color=red>public</font>、<font color=red>static</font>和<font color=red>final</font>进行修饰，即接口中的属性都是常量\n- 接口中的方法默认用<font color=red>public</font>和<font color=red>abstract</font>进行修饰，即接口中的方法都是抽象方法\n- 继承了接口的类必须实现接口中的抽象方法\n\n```java\n// 接口A\ninterface A {\n    String str = \"world\";\n    void print();\n}\n\n// 普通类B继承接口A\nclass B implements A {\n\n    @Override\n    public void print() {\n        System.out.println(\"Hello\");\n    }\n}\n\npublic class Demo {\n\n    public static void main(String[] args) {\n\n        // 实例化\n        A a = new B();\n        a.print();\n        System.out.println(A.str);\n\n        System.out.println(\"结束\");\n\n        /*\n         结果：\n         Hello\n         world\n         结束\n         */\n\n    }\n\n}\n```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 11. 内部类\n\n- 内部类就是是在类中定义的类，若在A类中定义了一个内部类B，那么B类就叫A类的内部类，相对的A类就叫B类的外部类\n- 内部类一般分为：成员内部类、静态内部类、局部内部类和匿名内部类\n\n#### 11.1 成员内部类\n\n- 成员内部类就是与成员变量、方法并列的地方定义的类\n\n- 成员内部类可以访问外部类的私有属性、方法\n\n- 要实例化成员内部类必须先实例化外部类\n\n  ```java\n  // 外部类A\n  class A {\n  \n      private String str = \"Hello\";\n  \n      private void print() {\n          System.out.println(\"world\");\n      }\n  \n      // 内部类B\n      class B {\n  \n          public String getStr() {\n              return str; // 访问外部类的私有变量\n          }\n  \n          public void printA() {\n              print(); // 调用的外部类私有方法\n          }\n  \n      }\n  \n  }\n  \n  public class Demo {\n  \n      public static void main(String[] args) {\n  \n          // 实例化\n          // B b = new B();  不能直接实例化内部类，编译报错\n          A.B b = new A().new B();\n          System.out.println(b.getStr());\n          b.printA();\n  \n          System.out.println(\"结束\");\n  \n          /*\n           结果：\n           Hello\n           world\n           结束\n           */\n  \n      }\n  \n  }\n  ```\n\n#### 11.2 静态内部类\n\n- 静态内部类就是在成员内部类上加上static关键字修饰\n\n- 静态内部类可以直接实例化\n\n- 静态内部类只能访问外部类的静态属性、静态方法\n\n  ```java\n  // 外部类A\n  class A {\n  \n      private static String str = \"Hello\";\n  \n      private static void print() {\n          System.out.println(\"world\");\n      }\n  \n      // 静态内部类B\n      static class B {\n  \n          public String getStr() {\n              return str; // 访问外部类的静态私有变量\n          }\n  \n          public void printA() {\n              print(); // 调用外部类的静态私有方法\n          }\n  \n      }\n  \n  }\n  \n  public class Demo {\n  \n      public static void main(String[] args) {\n  \n          // 实例化\n          A.B b = new A.B();\n          System.out.println(b.getStr());\n          b.printA();\n  \n          System.out.println(\"结束\");\n  \n          /*\n           结果：\n           Hello\n           world\n           结束\n           */\n  \n      }\n  \n  }\n  ```\n\n#### 11.3 局部内部类\n\n- 局部内部类就是在方法内定义的类\n\n- 局部内部类不能加任何的修饰符\n\n- 局部内部的作用域只在定义的方法内\n\n- 局部内部类可以访问方法中的变量\n\n  ```java\n  // 外部类A\n  class A {\n  \n      private String str = \"Hello\";\n  \n      public void print() {\n  \n          String str2 = \"world\";\n  \n          // 局部内部类B\n          class B {\n  \n              public String getStr() {\n                  return str; // 访问外部类的私有变量\n              }\n  \n              public void printL() {\n                  System.out.println(str2); // 访问方法内的变量\n              }\n  \n          }\n  \n          B b = new B();\n          System.out.println(b.getStr());\n          b.printL();\n  \n      }\n  \n  }\n  \n  public class Demo {\n  \n      public static void main(String[] args) {\n  \n          // 实例化\n          A a = new A();\n          a.print();\n  \n          System.out.println(\"结束\");\n  \n          /*\n           结果：\n           Hello\n           world\n           结束\n           */\n  \n      }\n  \n  }\n  ```\n\n#### 11.4 匿名内部类\n\n- 匿名内部类是使用时临时创建出来的类，他没有类名，只有类体，适用于代码中只使用一次的情况\n\n- 匿名类是唯一没有构造器的类\n\n- 匿名类一般需要一个接口作为模板\n\n  ```java\n  interface A {\n      void printL();\n  }\n  \n  public class Demo {\n  \n      public static void print(A a) {\n          a.printL();\n      }\n  \n      public static void main(String[] args) {\n  \n          print(new A() {   // 匿名内部类B\n  \n              @Override\n              public void printL() {\n                  System.out.println(\"Hello!\");\n              }\n  \n          });\n  \n          System.out.println(\"结束\");\n  \n          /*\n           结果：\n           Hello!\n           结束\n           */\n  \n      }\n  \n  }\n  ```","categoryId":"1","categoryName":"技术记录","tags":[{"id":"2","name":"Java"}],"views":1,"topping":false,"status":1,"createTime":"2022-10-24 20:48:01"}}