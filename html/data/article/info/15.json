{"code":0,"message":"获取文章简要信息成功!","data":{"id":"15","title":"Java生产者/消费者问题","description":"Java生产者/消费者问题","cover":"","content":"- 生产者/消费者问题也称有限缓冲问题，是一个多线程同步的问题\n- 生产者/消费者问题描述了两个共享共同大小缓冲区的线程之间如何处理生产数据和处理数据的关系的问题\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 管程法\n\n- 管程法是解决生产者/消费者问题的一种方法，该方法中主要包含三部分：\n\n  - 生产者：负责生产数据的模块（可能是方法、对象、线程、进程）\n  - 消费者：负责处理数据的模块（可能是方法、对象、线程、进程）\n  - 缓冲区：用于存放数据的地方，可以被生产者和消费者操作\n\n- 执行过程：生产者将数据放入缓冲区，消费者将数据从缓冲区拿出\n\n- 代码案例：\n\n  ```java\n  // 生产者\n  class Producer implements Runnable {\n  \n      private Table table;\n  \n      public Producer(Table table) {\n          this.table = table;\n      }\n  \n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              try {\n                  this.produce(i+1); // 制作面包\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n      }\n  \n      // 制作面包\n      public void produce(int i) throws InterruptedException {\n  \n          synchronized (this.table) {\n  \n              if (this.table.getCount() >= Table.MAX) {\n                  this.table.wait();  // 等待消费者消费\n              }\n  \n              Bread bread = new Bread(\"制作的第\" + i + \"个面包\");    // 制作一个新的面包\n              this.table.push(bread); // 将面包放到摊桌上\n              System.out.println(\"制作了第\" + i + \"个面包,当前面包数为\"+this.table.getCount());\n              this.table.notifyAll();    // 通知消费者消费\n  \n          }\n  \n      }\n  \n  }\n  \n  // 消费者\n  class Consumer implements Runnable {\n  \n      private Table table;\n  \n      public Consumer(Table table) {\n          this.table = table;\n      }\n  \n      @Override\n      public void run() {\n  \n          for (int i = 0; i < 100; i++) {\n              try {\n                  this.consume(); // 消费面包\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n  \n      }\n  \n      // 消费面包\n      public void consume() throws InterruptedException {\n  \n          synchronized (this.table) {\n  \n              if (this.table.getCount() == 0) {\n                  this.table.wait();  // 等待生产者生产\n              }\n  \n              Bread bread = this.table.pop(); // 将面包从摊桌上拿出\n              System.out.println(\"正在吃\"+bread.getName());  // 吃面包\n              this.table.notifyAll();    // 通知生产者生产\n  \n          }\n  \n      }\n  \n  }\n  \n  // 产品：面包\n  class Bread {\n  \n      private String name;\n  \n      public String getName() {\n          return this.name;\n      }\n  \n      public Bread(String name) {\n          this.name = name;\n      }\n  \n  }\n  \n  // 缓冲区：摊桌\n  class Table {\n  \n      public static final int MAX = 10;   // 最大面包数\n  \n      private Bread[] breads = new Bread[MAX]; // 面包数组\n      private int count = 0;  // 当前面包数\n  \n      public int getCount() {\n          return this.count;\n      }\n  \n      // 放入面包\n      public void push(Bread bread) {\n          this.breads[count++] = bread;\n      }\n  \n      // 拿出面包\n      public Bread pop() {\n          return this.breads[--count];\n      }\n  \n  }\n  \n  // 生产者/消费者问题解决1：管程法\n  public class ProducerAndConsumerDemo01 {\n  \n      public static void main(String[] args) {\n  \n          // 创建启动线程\n          Table table = new Table();\n          new Thread(new Producer(table)).start();\n          new Thread(new Consumer(table)).start();\n  \n      }\n  \n  }\n  ```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 信号灯法\n\n- 信号灯法是解决生产者/消费者问题的另一种方法，该方法中主要用一个”信号灯“(标志位)来通知生产者生产或消费者消费\n\n- 执行过程：生产者先生产数据然后改变标志位，消费者看到标志位改变后拿走数据\n\n- 代码案例：\n\n  ```java\n  // 生产者：视频制作UP\n  class Producer2 implements Runnable {\n  \n      private Bilibili bilibili;\n  \n      public Producer2(Bilibili bilibili) {\n          this.bilibili = bilibili;\n      }\n  \n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              try {\n                  this.makeVideo(i+1);    // 制作视频\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n      }\n  \n      // 制作视频\n      public void makeVideo(int i) throws InterruptedException {\n  \n          synchronized (this.bilibili) {\n  \n              while (this.bilibili.isFlag()) {\n                  System.out.println(\"再发个动态~~~\");\n                  this.bilibili.wait();   // 等待消费者观看\n              }\n  \n              this.bilibili.push(\"第\"+i+\"个视频\");    // 传入一个视频\n              System.out.println(\"UP主制作了第\"+i+\"个视频，发个动态让粉丝观看~~~\");\n              this.bilibili.notifyAll();  // 通知消费者观看\n  \n          }\n  \n      }\n  \n  }\n  \n  // 消费者：观众\n  class Consumer2 implements Runnable {\n  \n      private Bilibili bilibili;\n  \n      public Consumer2(Bilibili bilibili) {\n          this.bilibili = bilibili;\n      }\n  \n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              try {\n                  this.watchVideo();\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n      }\n  \n      // 观看视频\n      public void watchVideo() throws InterruptedException {\n  \n          synchronized (this.bilibili) {\n  \n              while (!this.bilibili.isFlag()) {\n                  System.out.println(\"没有视频看，催更~~~\");\n                  this.bilibili.wait();\n              }\n  \n              System.out.println(\"粉丝观看UP主的\"+this.bilibili.pop());\n              System.out.println(\"看完了，催更~~~\");\n              this.bilibili.notifyAll();  // 通知生产者制作视频\n  \n          }\n  \n      }\n  \n  }\n  \n  // 产品：Bilibili视频\n  class Bilibili {\n  \n      private String video;    // 视频\n      private boolean flag = false;   // 有无视频\n  \n      public boolean isFlag() {\n          return flag;\n      }\n  \n      // 传入视频\n      public void push(String video) {\n          this.change();\n          this.video = video;\n      }\n  \n      // 传出视频\n      public String pop() {\n          this.change();\n          return this.video;\n      }\n  \n      // 改变标志符\n      private void change() {\n          this.flag = !this.flag;\n      }\n  \n  }\n  \n  \n  // 生产者/消费者问题解决2：信号灯法\n  public class ProducerAndConsumerDemo02 {\n  \n      public static void main(String[] args) {\n  \n          // 创建启动线程\n          Bilibili bilibili = new Bilibili();\n          new Thread(new Producer2(bilibili)).start();\n          new Thread(new Consumer2(bilibili)).start();\n  \n      }\n  \n  }\n  ```\n\n  ","categoryId":"1","categoryName":"技术记录","tags":[{"id":"2","name":"Java"}],"views":1,"topping":false,"status":1,"createTime":"2022-10-24 20:55:19"}}