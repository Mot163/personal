{"code":0,"message":"获取文章简要信息成功!","data":{"id":"21","title":"RabbitMQ中间件部署及使用","description":"RabbitMQ中间件部署及使用","cover":"","content":"## RabbitMQ中间件部署及使用\n\n&nbsp;\n\n### 1. RabbitMQ的部署\n\n#### 1.1 CentOS7.x下的直接部署\n\n- 下载RabbitMQ安装包[rabbitmq-server-3.8.14-1.el7.noarch.rpm]：https://wwe.lanzous.com/ibMV4n0uj8f\n- 下载Erlang安装包[erlang-solutions-2.0-1.noarch.rpm]：https://wwe.lanzous.com/iZRumn0uj9g\n- 将安装包上传到CentOS中\n- 安装\n\n```bash\n# 1. 安装erlang环境\nrpm -Uvh erlang-solutions-2.0-1.noarch.rpm\nyum install -y erlang\n# 2. 安装socat插件\nyum install -y socat\n# 3. 安装rabbitMQ\nrpm -Uvh rabbitmq-server-3.8.14-1.el7.noarch.rpm\nyum install -y rabbitmq-server\n```\n\n- 启动与关闭\n\n```bash\n# 启动rabbitMQ\nsystemctl start rabbitmq-server\n# 查看rabbitMQ状态\nsystemctl status rabbitmq-server\n# 停止rabbitMQ\nsystemctl stop rabbitmq-server\n# 开机启动rabbitMQ\nsystemctl enable rabbitmq-server\n```\n\n- 打开web管理\n\n```bash\n# 开启web管理插件\nrabbitmq-plugins enable rabbitmq_management\n# 重启rabbitMQ服务\nsystemctl restart rabbitmq-server\n```\n\n- 用户添加与设置\n\n```bash\n# 添加用户（admin admin为用户账号和密码）\nrabbitmqctl add_user admin admin\n# 设置用户为管理员\nrabbitmqctl set_user_tags admin administrator\n# 为用户添加资源权限\nrabbitmqctl set_permissions -p / admin \".*\" \".*\" \".*\"\n```\n\n---\n\n#### 1.2 CentOS7.x下通过Docker的安装部署\n\n- 安装Docker\n\n```bash\n# 1. 将yum包更新到最新\nyum update\n# 2. 安装依赖\nyum install -y yum-utils device-mapper-persistent-data lvm2\n# 3. 设置yum源为阿里云\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n# 4. 安装docker\nyum install -y docker-ce\n# 5. 安装加速镜像\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-'EOF'\n{\n \"registry-mirrors\":[\"https://hub-mirror.c.163.com/\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n- Docker的启动和关闭\n\n```bash\n# 启动docker\nsystemctl start docker\n# 关闭docker\nsystemctl stop docker\n```\n\n- 通过Docker安装rabbitMQ（包含用户与web管理）\n\n```bash\ndocker run -di --name rabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 5672:5672 -p 15672:15672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management\n```\n\n---\n\n#### 1.3 RabbitMQ的web管理访问\n\n- 阿里云、腾讯云等的服务器需通过安全组打开15672、5672等端口\n- 其他服务器需通过防火墙打开15672、5672等端口\n\n```bash\n# 开放15672和5672端口\nfirewall-cmd --zone=public --add-port=15672/tcp --permanent\nfirewall-cmd --zone=public --add-port=5672/tcp --permanent\n# 配置立即生效\nfirewall-cmd --reload\n\n# 其他相关命令\n# 关闭15672和5672端口\nfirewall-cmd --zone=public --remove-port=15672/tcp --permanent\nfirewall-cmd --zone=public --remove-port=5672/tcp --permanent\n# 查看防火墙所有开放的端口\nfirewall-cmd --zone=public --list-ports\n```\n\n- 输入http://ip:15672/访问web管理\n\n&nbsp;\n\n---\n\n&nbsp;\n\n### 2. RabbitMQ的使用\n\n#### 2.1 SpringBoot整合RabbitMQ\n\n- 新建Spring项目\n- pom.xml依赖\n\n```xml\n<dependencies>\n\n    <!--RabbitMQ启动依赖-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-amqp</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n\n    <!--测试依赖-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.amqp</groupId>\n        <artifactId>spring-rabbit-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n\n</dependencies>\n```\n\n- application.yml配置\n\n```yaml\n# 服务器端口\nserver:\n  port: 8080\n\n# RabbitMQ服务配置\nspring:\n  rabbitmq:\n    username: admin\n    password: admin\n    virtual-host: /\n    host: 192.168.150.128\n    port: 5672\n```\n\n- RabbitMQConfiguration消息队列配置类\n\n```java\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.DirectExchange;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * RabbitMQ配置类\n */\n@Configuration\npublic class RabbitMQConfiguration {\n\n    /**\n     * 声明交换机（类型有DirectExchange、FanoutExchange、TopicExchange、HeadersExchange）\n     */\n    @Bean\n    public DirectExchange directExchange() {\n        /*\n            @param1 交换机的名称\n            @param2 交换机是否持久化\n            @param3 交换机是否自动删除\n         */\n        return new DirectExchange(\"direct_exchange_01\", true, false);\n    }\n\n    /**\n     * 声明队列1\n     */\n    @Bean\n    public Queue queue1() {\n        /*\n            @param1 队列的名称\n            @param2 队列是否持久化\n         */\n        return new Queue(\"01.queue\", true);\n    }\n\n    /**\n     * 声明队列2\n     */\n    @Bean\n    public Queue queue2() {\n        return new Queue(\"02.queue\", true);\n    }\n\n    /**\n     * 声明队列3\n     */\n    @Bean\n    public Queue queue3() {\n        return new Queue(\"03.queue\", true);\n    }\n\n    /**\n     * 队列1与交换机绑定\n     */\n    @Bean\n    public Binding queue1Binding() {\n        return BindingBuilder\n                .bind(queue1())         // 要进行绑定的队列\n                .to(directExchange())   // 队列绑定的交换机\n                .with(\"1\");   // 队列的路由Key（Fanout类型的交换机不需要）\n    }\n\n    /**\n     * 队列2与交换机绑定\n     */\n    @Bean\n    public Binding queue2Binding() {\n        return BindingBuilder\n                .bind(queue2())\n                .to(directExchange())\n                .with(\"2\");\n    }\n\n    /**\n     * 队列3与交换机绑定\n     */\n    @Bean\n    public Binding queue3Binding() {\n        return BindingBuilder\n                .bind(queue3())\n                .to(directExchange())\n                .with(\"3\");\n    }\n\n}\n```\n\n---\n\n#### 2.2 简单使用案例\n\n- 生产者\n\n  - Service接口\n\n  ```java\n  public interface ProducerService {\n      void sendMessage(String routingKey, String message);\n  }\n  ```\n\n  - Service实现类\n\n  ```java\n  import com.mo.rabbitmqproducer.service.ProducerService;\n  import org.springframework.amqp.rabbit.core.RabbitTemplate;\n  import org.springframework.beans.factory.annotation.Autowired;\n  import org.springframework.stereotype.Service;\n  \n  @Service\n  public class ProducerServiceImpl implements ProducerService {\n  \n      @Autowired\n      private RabbitTemplate rabbitTemplate;\n  \n      @Override\n      public void sendMessage(String routingKey, String message) {\n          // 交换机名称\n          String exchangeName = \"direct_exchange_01\";\n          // 发给消息队列\n          rabbitTemplate.convertAndSend(exchangeName, routingKey, message);\n          System.out.println(\"发送消息成功\");\n      }\n  \n  }\n  ```\n\n- 消费者\n\n  - Service接口\n\n  ```java\n  public interface ConsumerService {\n      void receiveMessage(String message);\n  }\n  ```\n\n  - Service实现类\n\n  ```java\n  import com.mo.rabbitmqconsumer.service.ConsumerService;\n  import org.springframework.amqp.rabbit.annotation.RabbitHandler;\n  import org.springframework.amqp.rabbit.annotation.RabbitListener;\n  import org.springframework.stereotype.Service;\n  \n  @Service\n  @RabbitListener(queues = {\"01.queue\"})\n  public class Consumer01ServiceImpl implements ConsumerService {\n  \n      @Override\n      @RabbitHandler\n      public void receiveMessage(String message) {\n          System.out.println(\"消费者01接收到消息：\" + message);\n      }\n  \n  }\n  ```\n\n  ```java\n  import com.mo.rabbitmqconsumer.service.ConsumerService;\n  import org.springframework.amqp.rabbit.annotation.RabbitHandler;\n  import org.springframework.amqp.rabbit.annotation.RabbitListener;\n  import org.springframework.stereotype.Service;\n  \n  @Service\n  @RabbitListener(queues = {\"02.queue\"})\n  public class Consumer02ServiceImpl implements ConsumerService {\n  \n      @Override\n      @RabbitHandler\n      public void receiveMessage(String message) {\n          System.out.println(\"消费者02接收到消息：\" + message);\n      }\n  \n  }\n  ```\n\n  ```java\n  import com.mo.rabbitmqconsumer.service.ConsumerService;\n  import org.springframework.amqp.rabbit.annotation.RabbitHandler;\n  import org.springframework.amqp.rabbit.annotation.RabbitListener;\n  import org.springframework.stereotype.Service;\n  \n  @Service\n  @RabbitListener(queues = {\"03.queue\"})\n  public class Consumer03ServiceImpl implements ConsumerService {\n  \n      @Override\n      @RabbitHandler\n      public void receiveMessage(String message) {\n          System.out.println(\"消费者03接收到消息：\" + message);\n      }\n  \n  }\n  ```\n\n- 测试\n\n  ```java\n  import com.mo.rabbitmqproducer.service.ProducerService;\n  import org.junit.jupiter.api.Test;\n  import org.springframework.beans.factory.annotation.Autowired;\n  import org.springframework.boot.test.context.SpringBootTest;\n  \n  @SpringBootTest\n  class RabbitmqProducerApplicationTests {\n  \n      @Autowired\n      private ProducerService producerService;\n  \n      @Test\n      void contextLoads() {\n          producerService.sendMessage(\"1\", \"Hello 01!\");\n          producerService.sendMessage(\"2\", \"Hello 02!\");\n          producerService.sendMessage(\"3\", \"Hello 03!\");\n      }\n  \n  }\n  ```\n\n---\n\n#### 2.3 TTL消息过期\n\n- 可设置队列的过期时间让队列中的消息过期后删除或转移\n\n  - RabbitMQConfiguration消息队列配置类\n\n  ```java\n  import org.springframework.amqp.core.Binding;\n  import org.springframework.amqp.core.BindingBuilder;\n  import org.springframework.amqp.core.DirectExchange;\n  import org.springframework.amqp.core.Queue;\n  import org.springframework.context.annotation.Bean;\n  import org.springframework.context.annotation.Configuration;\n  \n  import java.util.HashMap;\n  import java.util.Map;\n  \n  /**\n   * RabbitMQ配置类\n   */\n  @Configuration\n  public class RabbitMQConfiguration2 {\n  \n      /**\n       * 声明交换机\n       */\n      @Bean\n      public DirectExchange ttlDirectExchange() {\n          /*\n              @param1 交换机的名称\n              @param2 交换机是否持久化\n              @param3 交换机是否自动删除\n           */\n          return new DirectExchange(\"ttl_direct_exchange\", true, false);\n      }\n  \n      /**\n       * 声明过期队列\n       */\n      @Bean\n      public Queue ttlQueue() {\n          // 设置过期时间\n          Map<String, Object> args = new HashMap<>();\n          args.put(\"x-message-ttl\", 5000);    // 过期时间为5000毫秒\n          /*\n              @param1 队列的名称\n              @param2 队列是否持久化\n              @param3 队列的排他性\n              @param4 队列是否自动删除\n              @param5 队列属性\n           */\n          return new Queue(\"ttl.direct.queue\", true, false, false, args);\n      }\n  \n      /**\n       * 队列与交换机绑定\n       */\n      @Bean\n      public Binding ttlQueueBinding() {\n          return BindingBuilder\n                  .bind(ttlQueue())         // 要进行绑定的队列\n                  .to(ttlDirectExchange())   // 队列绑定的交换机\n                  .with(\"ttl\");   // 队列的路由Key（Fanout类型的交换机不需要）\n      }\n  \n  }\n  ```\n\n- 可设置消息的过期时间让消息到队列中过期后删除\n\n  - 设置消息过期的方法\n\n  ```java\n  public void ttlMessage(String routingKey, String message) {\n      // 交换机名称\n      String exchangeName = \"direct_exchange_01\";\n      // 设置消息过期时间\n      MessagePostProcessor messagePostProcessor = msg -> {\n          msg.getMessageProperties().setExpiration(\"5000\");   // 设置过期时间为5000毫秒\n          return null;\n      };\n      // 发给消息队列\n      rabbitTemplate.convertAndSend(exchangeName, routingKey, message, messagePostProcessor);\n      System.out.println(\"发送消息成功\");\n  }\n  ```\n\n- 同时设置了队列的过期时间和消息的过期时间时，以最短时间为准\n\n---\n\n#### 2.4 死信队列\n\n- 死信队列用于消息被拒绝、消息过期、队列已达最大长度时消息的接收\n\n  - RabbitMQConfiguration消息队列配置类\n\n  ```java\n  import org.springframework.amqp.core.Binding;\n  import org.springframework.amqp.core.BindingBuilder;\n  import org.springframework.amqp.core.DirectExchange;\n  import org.springframework.amqp.core.Queue;\n  import org.springframework.context.annotation.Bean;\n  import org.springframework.context.annotation.Configuration;\n  \n  import java.util.HashMap;\n  import java.util.Map;\n  \n  /**\n   * RabbitMQ配置类\n   */\n  @Configuration\n  public class RabbitMQConfiguration3 {\n  \n      /**\n       * 声明死信交换机\n       */\n      @Bean\n      public DirectExchange deadDirectExchange() {\n          /*\n              @param1 交换机的名称\n              @param2 交换机是否持久化\n              @param3 交换机是否自动删除\n           */\n          return new DirectExchange(\"dead_direct_exchange\", true, false);\n      }\n  \n      /**\n       * 声明死信队列\n       */\n      @Bean\n      public Queue deadQueue() {\n          return new Queue(\"ttl.direct.queue\", true);\n      }\n  \n      /**\n       * 队列与交换机绑定\n       */\n      @Bean\n      public Binding deadQueueBinding() {\n          return BindingBuilder\n                  .bind(deadQueue())         // 要进行绑定的队列\n                  .to(deadDirectExchange())   // 队列绑定的交换机\n                  .with(\"dead\");   // 队列的路由Key（Fanout类型的交换机不需要）\n      }\n  \n      /**\n       * 声明过期交换机\n       */\n      @Bean\n      public DirectExchange ttlDirectExchange2() {\n          /*\n              @param1 交换机的名称\n              @param2 交换机是否持久化\n              @param3 交换机是否自动删除\n           */\n          return new DirectExchange(\"ttl_direct_exchange2\", true, false);\n      }\n  \n      /**\n       * 声明过期队列\n       */\n      @Bean\n      public Queue ttlQueue2() {\n          // 设置过期时间\n          Map<String, Object> args = new HashMap<>();\n          args.put(\"x-message-ttl\", 5000);    // 过期时间为5000毫秒\n          args.put(\"x-max-length\", 10);   // 消息队列的最大长度\n          args.put(\"x-dead-letter-exchange\", \"dead_direct_exchange\"); // 设置死信交换机\n          args.put(\"x-dead-letter-routing-key\", \"dead\");  //  设置路由Key（Fanout模式交换机不需要设置）\n          /*\n              @param1 队列的名称\n              @param2 队列是否持久化\n              @param3 队列的排他性\n              @param4 队列是否自动删除\n              @param5 队列属性\n           */\n          return new Queue(\"ttl2.direct.queue\", true, false, false, args);\n      }\n  \n      /**\n       * 队列与交换机绑定\n       */\n      @Bean\n      public Binding ttlQueueBinding2() {\n          return BindingBuilder\n                  .bind(ttlQueue2())         // 要进行绑定的队列\n                  .to(ttlDirectExchange2())   // 队列绑定的交换机\n                  .with(\"ttl2\");   // 队列的路由Key（Fanout类型的交换机不需要）\n      }\n  \n  }\n  ```\n\n---\n\n#### 2.5 内存磁盘的预警管理控制\n\n- 内存的预警管理控制\n\n  - 命令行的方式（重启后失效）\n\n  ```bash\n  # 相对大小，默认方式，默认值为0.4，建议设置范围为0.4~0.7\n  rabbitmqctl set_vm_memory_high_watermark relative 0.5\n  # 绝对大小\n  rabbitmqctl set_vm_memory_high_watermark absolute 100MB\n  ```\n\n  - 配置文件方式（重启后不失效）\n\n  ```bash\n  vim /etc/rabbitmq/rabbitmq.conf\n  # 修改对应值\n  # 相对大小，默认方式，默认值为0.4，建议设置范围为0.4~0.7\n  vm_memory_high_watermark.relative = 0.5\n  # 绝对大小\n  vm_memory_high_watermark.absolute = 100MB\n  # 内存换页，当内存达到一个界限就将内存置换到磁盘，默认值为0.5，设置值应该小于1\n  vm_memory_high_watermark_paging_ratio.relative = 0.5\n  ```\n\n- 磁盘的预警管理控制\n\n  - 命令行的方式（重启后失效）\n\n  ```bash\n  # 相对内存大小，建议设置范围为1.0~2.0\n  rabbitmqctl set_disk_free_limit memory_limit 1.5\n  # 绝对大小，默认方式，默认值为50MB\n  rabbitmqctl set_disk_free_limit 100MB\n  ```\n\n  - 配置文件方式（重启后不失效）\n\n  ```bash\n  vim /etc/rabbitmq/rabbitmq.conf\n  # 修改对应值\n  # 相对内存大小，建议设置范围为1.0~2.0\n  disk_free_limit.relative = 1.5\n  # 绝对大小，默认方式，默认值为50MB\n  disk_free_limit.absolute = 100MB\n  ```\n\n---\n\n#### 2.6 集群\n\n- 单机集群的搭建（节点1为主节点，节点2为从节点）\n\n```bash\n# 1. 启动第一个节点\nsudo RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit-1 rabbit-server start &\n# 2. 启动第二个节点\nsudo RABBITMQ_NODE_PORT=5673 RABBITMQ_SERVER_ARGS=\"-rabbitmq_management listener [{port,15673}]\" RABBITMQ_NODENAME=rabbit-2 rabbit-server start &\n# 3. 停止节点1并清除节点的历史数据，再启动\nsudo rabbitmqctl -n rabbit-1 stop_app\nsudo rabbitmqctl -n rabbit-1 reset\nsudo rabbitmqctl -n rabbit-1 start_app\n# 4. 停止节点2并清除节点的历史数据，绑定节点1再启动（Server-node为主机名或IP地址）\nsudo rabbitmqctl -n rabbit-2 stop_app\nsudo rabbitmqctl -n rabbit-2 reset\nsudo rabbitmqctl -n rabbit-2 join_cluster rabbit-1@'Server-node'\nsudo rabbitmqctl -n rabbit-2 start_app\n```\n\n- 节点用户添加\n\n```bash\n# 为第一、第二个节点添加用户\nrabbitmqctl -n rabbit-1 add_user admin admin\nrabbitmqctl -n rabbit-2 add_user admin admin\n# 设置用户为管理员\nrabbitmqctl -n rabbit-1 set_user_tags admin administrator\nrabbitmqctl -n rabbit-2 set_user_tags admin administrator\n# 为用户添加资源权限\nrabbitmqctl -n rabbit-1 set_permissions -p / admin \".*\" \".*\" \".*\"\nrabbitmqctl -n rabbit-2 set_permissions -p / admin \".*\" \".*\" \".*\"\n```\n\n---\n\n#### 2.7 分布式事务\n\n- application配置\n\n```yaml\n# 服务器端口\nserver:\n  port: 8081\n\n# RabbitMQ服务配置\nspring:\n  rabbitmq:\n    username: admin\n    password: admin\n    virtual-host: /\n    host: 192.168.150.128\n    port: 5672\n    #addresses: 192.168.150.128:5672\t  # 集群IP及端口连接方式\n    publisher-confirm-type: correlated  # 消息确认机制\n    publisher-returns: true # 开启发送失败退回\n    \n    template:\n      mandatory: true # 保证监听有效\n      \n    listener:\n      simple:\n        acknowledge-mode: manual  # 手动ACK机制\n        concurrency: 1  # 消费者最小数\n        max-concurrency: 10 # 消费者最大处\n        retry:\n          enabled: true # 支持重试/重发\n```\n\n- RabbitMQConfiguration消息队列配置类\n\n```java\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.DirectExchange;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * RabbitMQ配置类\n */\n@Configuration\npublic class RabbitMQConfiguration4 {\n\n    /**\n     * 声明死信交换机\n     */\n    @Bean\n    public DirectExchange deadDirectExchange2() {\n        /*\n            @param1 交换机的名称\n            @param2 交换机是否持久化\n            @param3 交换机是否自动删除\n         */\n        return new DirectExchange(\"dead_direct_exchange2\", true, false);\n    }\n\n    /**\n     * 声明死信队列\n     */\n    @Bean\n    public Queue deadQueue2() {\n        return new Queue(\"dead2.direct.queue\", true);\n    }\n\n    /**\n     * 队列与交换机绑定\n     */\n    @Bean\n    public Binding deadQueueBinding2() {\n        return BindingBuilder\n                .bind(deadQueue2())         // 要进行绑定的队列\n                .to(deadDirectExchange2())   // 队列绑定的交换机\n                .with(\"dead2\");   // 队列的路由Key（Fanout类型的交换机不需要）\n    }\n\n    /**\n     * 声明交换机\n     */\n    @Bean\n    public DirectExchange directExchange2() {\n        /*\n            @param1 交换机的名称\n            @param2 交换机是否持久化\n            @param3 交换机是否自动删除\n         */\n        return new DirectExchange(\"direct_exchange2\", true, false);\n    }\n\n    /**\n     * 声明队列\n     */\n    @Bean\n    public Queue directQueue2() {\n        Map<String, Object> args = new HashMap<>();\n        args.put(\"x-dead-letter-exchange\", \"dead_direct_exchange2\"); // 设置死信交换机\n        args.put(\"x-dead-letter-routing-key\", \"dead2\");  //  设置路由Key（Fanout模式交换机不需要设置）\n        /*\n            @param1 队列的名称\n            @param2 队列是否持久化\n            @param3 队列的排他性\n            @param4 队列是否自动删除\n            @param5 队列属性\n         */\n        return new Queue(\"direct2.queue\", true, false, false, args);\n    }\n\n    /**\n     * 队列与交换机绑定\n     */\n    @Bean\n    public Binding directQueueBinding2() {\n        return BindingBuilder\n                .bind(directQueue2())         // 要进行绑定的队列\n                .to(directExchange2())   // 队列绑定的交换机\n                .with(\"direct2\");   // 队列的路由Key（Fanout类型的交换机不需要）\n    }\n\n}\n```\n\n- 生产者\n\n  - Service接口\n\n  ```java\n  public interface ProducerTXService {\n      void sendTXMessage(String message);\n  }\n  ```\n\n  - Service实现类\n\n  ```java\n  import com.mo.rabbitmqproducer.service.ProducerTXService;\n  import org.springframework.amqp.rabbit.connection.CorrelationData;\n  import org.springframework.amqp.rabbit.core.RabbitTemplate;\n  import org.springframework.beans.factory.annotation.Autowired;\n  import org.springframework.stereotype.Service;\n  \n  import javax.annotation.PostConstruct;\n  \n  @Service\n  public class ProducerTXServiceImpl implements ProducerTXService {\n  \n      @Autowired\n      private RabbitTemplate rabbitTemplate;\n  \n      @PostConstruct\n      public void regCallback() {\n          // 添加一个消息确认的回调方法\n          rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {\n              System.out.println(\"cause：\" + cause);\n  \n              if (!ack) {\n                  // 应答失败操作\n                  System.out.println(\"MQ消息应答失败\");\n                  return;\n              }\n  \n              try {\n                  System.out.println(\"更改消息投递状态\");\n                  System.out.println(\"消息投递成功\");\n              } catch (Exception e) {\n                  System.out.println(\"消息状态修改失败\");\n                  System.out.println(\"异常操作\");\n              }\n          });\n      }\n  \n      @Override\n      public void sendTXMessage(String message) {\n          // 交换机名称\n          String exchangeName = \"direct_exchange2\";\n          // 路由Key\n          String routingKey = \"direct2\";\n          // 发给消息队列\n          rabbitTemplate.convertAndSend(exchangeName, routingKey, message, new CorrelationData(message));\n      }\n  \n  }\n  ```\n\n- 消费者\n\n  - Service接口\n\n  ```java\n  import com.rabbitmq.client.Channel;\n  import org.springframework.amqp.rabbit.connection.CorrelationData;\n  \n  public interface ConsumerTXService {\n      void receiveTXMessage(String message, Channel channel, CorrelationData correlationData, long tag);\n  }\n  ```\n\n  - Service实现类\n\n  ```java\n  import com.mo.rabbitmqconsumer.service.ConsumerTXService;\n  import com.rabbitmq.client.Channel;\n  import org.springframework.amqp.rabbit.annotation.RabbitListener;\n  import org.springframework.amqp.rabbit.connection.CorrelationData;\n  import org.springframework.amqp.support.AmqpHeaders;\n  import org.springframework.messaging.handler.annotation.Header;\n  import org.springframework.stereotype.Service;\n  \n  import java.io.IOException;\n  \n  @Service\n  public class ConsumerTXServiceImpl implements ConsumerTXService {\n  \n      @Override\n      @RabbitListener(queues = {\"direct2.queue\"})\n      public void receiveTXMessage(String message, Channel channel,\n                                   CorrelationData correlationData,\n                                   @Header(AmqpHeaders.DELIVERY_TAG) long tag){\n          try {\n              // 获取消息队列的信息\n              System.out.println(\"收到的信息为：\" + message);\n              int a = 1/0;\n              // 自动应答\n              channel.basicAck(tag, false);\n          } catch (Exception e) {\n              try {\n                  // 手动应答\n                  channel.basicNack(tag, false, false);\n              } catch (IOException ioException) {\n                  ioException.printStackTrace();\n              }\n          }\n      }\n  \n  }\n  ```\n\n- 测试\n\n  ```java\n  import com.mo.rabbitmqproducer.service.ProducerTXService;\n  import org.junit.jupiter.api.Test;\n  import org.springframework.beans.factory.annotation.Autowired;\n  import org.springframework.boot.test.context.SpringBootTest;\n  \n  @SpringBootTest\n  class RabbitmqProducerApplicationTests {\n      \n      @Autowired\n      private ProducerTXService producerTXService;\n      \n      @Test\n      void contextLoads() {\n          producerTXService.sendTXMessage(\"hello\");\n      }\n  \n  }\n  ```","categoryId":"1","categoryName":"技术记录","tags":[{"id":"2","name":"Java"},{"id":"9","name":"中间件"},{"id":"10","name":"MQ"}],"views":3,"topping":false,"status":1,"createTime":"2022-10-24 21:01:49"}}