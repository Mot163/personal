{"code":0,"message":"获取文章简要信息成功!","data":{"id":"9","title":"Java多线程","description":"Java多线程","cover":"","content":"## 1. 概述\n\n- 多线程是指从软件或硬件上实现多个线程<font color=red>并发执行</font>的技术\n- 线程是CPU调度和执行的单位，其从属于进程\n- 进程是执行程序的一次执行过程，是系统资源分配的单位\n- 一个进程一般包含多个线程，其至少也要包含一个线程\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 2. 实现多线程\n\n#### 2.1 继承Thread类\n\n- <font color=red>Thread</font>类是Java中的一个线程类，继承了Thread类就可以实现多线程\n\n- 继承了Thread类就必须要重写它下面的<font color=red>run()</font>方法\n\n- 创建线程对象后调用<font color=red>start()</font>方法启动线程\n\n  ```java\n  // 继承Thread类实现多线程\n  public class ThreadDemo01_ExtendsThread extends Thread {\n  \n      // 重写run()方法\n      @Override\n      public void run() {\n  \n          for (int i = 1; i <= 200; i++) {\n              System.out.println(\"run()正在执行第\"+i+\"次\");\n          }\n  \n      }\n  \n      public static void main(String[] args) {\n  \n          ThreadDemo01_ExtendsThread t1 = new ThreadDemo01_ExtendsThread();\n          t1.start();\n  \n          for (int i = 1; i <= 200; i++) {\n              System.out.println(\"main()正在执行第\"+i+\"次\");\n          }\n  \n      }\n  \n  }\n  ```\n\n---\n\n#### 2.2 实现Runnable接口（推荐）\n\n- <font color=red>Runnable</font>接口是Java中实现多线程的接口，Thread类也实现了Runnable接口\n\n- 实现Runnable接口需要重写它下面的<font color=red>run()</font>方法\n\n- 通过Thread类间接创建线程对象，调用<font color=red>start()</font>方法启动线程\n\n  ```java\n  // 继承Runnable接口实现多线程\n  public class ThreadDemo02_ImplementsRunnable implements Runnable {\n  \n      // 重写run()方法\n      @Override\n      public void run() {\n  \n          for (int i = 1; i <= 100; i++) {\n              System.out.println(Thread.currentThread().getName()+\"正在执行第\"+i+\"次\");\n          }\n  \n      }\n  \n      public static void main(String[] args) {\n  \n          new Thread(new ThreadDemo02_ImplementsRunnable(),\"t1\").start();\n          new Thread(new ThreadDemo02_ImplementsRunnable(),\"t2\").start();\n          new Thread(new ThreadDemo02_ImplementsRunnable(),\"t3\").start();\n  \n      }\n  \n  }\n  ```\n\n---\n\n#### 2.3 实现Callable接口\n\n- <font color=red>Callable</font>接口是一个<font color=red>有返回值</font>的实现多线程的接口\n\n- 实现Runnable接口需要重写它下面的<font color=red>call()</font>方法\n\n- 通过Callable接口实现多线程的一般步骤：\n\n  1. 创建目标对象\n  2. 创建执行服务\n  3. 提交执行\n  4. 获取结果\n  5. 关闭服务\n\n  ```java\n  import java.util.concurrent.*;\n  \n  // 继承Callable接口实现多线程\n  public class ThreadDemo03_ImplementsCallable implements Callable<Boolean> {\n  \n      @Override\n      public Boolean call() throws Exception {\n  \n          for (int i = 0; i < 100; i++) {\n              System.out.println(Thread.currentThread().getName()+\"正在执行第\"+i+\"次\");\n          }\n  \n          return true;\n  \n      }\n  \n      public static void main(String[] args) throws ExecutionException, InterruptedException {\n  \n          // 实例化对象\n          ThreadDemo03_ImplementsCallable t1 = new ThreadDemo03_ImplementsCallable();\n          ThreadDemo03_ImplementsCallable t2 = new ThreadDemo03_ImplementsCallable();\n          ThreadDemo03_ImplementsCallable t3 = new ThreadDemo03_ImplementsCallable();\n  \n          // 创建执行服务\n          ExecutorService ser = Executors.newFixedThreadPool(3);\n  \n          // 提交执行\n          Future<Boolean> r1 = ser.submit(t1);\n          Future<Boolean> r2 = ser.submit(t2);\n          Future<Boolean> r3 = ser.submit(t3);\n  \n          // 获取结果\n          boolean rs1 = r1.get();\n          boolean rs2 = r2.get();\n          boolean rs3 = r3.get();\n  \n          // 关闭服务\n          ser.shutdown();\n  \n      }\n  \n  }\n  ```\n\n---\n\n#### 2.4 认识多线程的并发问题\n\n- 多个线程访问同一个对象时，会出现并发问题，其实质就是内存访问的线程调度问题\n\n- 一个买票代码案例：\n\n  ```java\n  // 售票机\n  class TicketMachine implements Runnable {\n  \n      private int tickets;    // 剩余票数\n  \n      public TicketMachine(int tickets) {\n          this.tickets = tickets;\n      }\n  \n      @Override\n      public void run() {\n  \n          while (this.tickets > 0) {\n              System.out.println(Thread.currentThread().getName() + \"拿到了第\" + this.tickets-- + \"张票，剩余\" + this.tickets + \"张\");\n              try {\n                  Thread.sleep(200);  // 模拟延时\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n  \n      }\n  }\n  \n  public class BuyTicketDemo01 {\n  \n      public static void main(String[] args) {\n  \n          // 创建售票机\n          TicketMachine tm = new TicketMachine(10);\n  \n          new Thread(tm,\"小明\").start();\n          new Thread(tm,\"小红\").start();\n          new Thread(tm,\"小王\").start();\n  \n          /*\n           可能结果：\n           小明拿到了第10张票，剩余9张\n           小红拿到了第9张票，剩余8张\n           小王拿到了第8张票，剩余7张\n           小红拿到了第7张票，剩余5张\n           小王拿到了第5张票，剩余4张\n           小明拿到了第6张票，剩余5张\n           小红拿到了第3张票，剩余1张\n           小王拿到了第4张票，剩余3张\n           小明拿到了第2张票，剩余1张\n           小王拿到了第1张票，剩余0张\n           小明拿到了第1张票，剩余0张\n           （票数出现错误，后面线程同步解决）\n           */\n  \n      }\n  \n  }\n  ```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 3. sleep()线程休眠\n\n- <font color=red>sleep()</font>是多线程的休眠方法，它能让当前线程阻塞指定时间\n\n- sleep()方法有一个毫秒的传入参数(1秒=1000毫秒)\n\n- sleep()执行结束后，线程进入就绪状态\n\n- sleep()可以模拟网络延时(用于测试中放大错误的发生性)、倒计时等\n\n- sleep()不会释放锁\n\n  ```java\n  // Thread.sleep()模拟延时、倒计时\n  public class ThreadDemo04_Sleep implements Runnable {\n  \n      @Override\n      public void run() {\n  \n          // 等待5秒\n          for (int i = 5; i > 0; i--) {\n              System.out.println(\"请等待\"+i+\"秒...\");\n              try {\n                  Thread.sleep(1000);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n  \n          System.out.println(\"等待结束！\");\n  \n      }\n  \n      public static void main(String[] args) {\n  \n          ThreadDemo04_Sleep t1 = new ThreadDemo04_Sleep();\n  \n          new Thread(t1).start();\n  \n      }\n  \n  }\n  ```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 4. ~~stop()~~线程停止\n\n- stop()、destroy()方法可以停止线程，但不推荐已经废弃了\n\n- 线程停止一般让线程自已停止\n\n- 建议使用<font color=red>标志位法</font>停止线程\n\n  ```java\n  // 线程停止（标志位法）\n  public class ThreadDemo05_Stop implements Runnable {\n  \n      private boolean flag = true;\t// 标志位\n  \n      @Override\n      public void run() {\n          int i = 1;\n          while (flag) {\n              System.out.println(\"run()正在运行...\"+i++);\n          }\n          System.out.println(\"run()停止运行\");\n      }\n  \n      public void stop() {\n          this.flag = false;\n      }\n  \n  \n      public static void main(String[] args) {\n  \n          ThreadDemo05_Stop t1 = new ThreadDemo05_Stop();\n  \n          new Thread(t1).start();\n  \n          for (int i = 0; i < 500; i++) {\n              if(i == 250) {\n                  t1.stop();\n              }\n              System.out.println(\"main()正在运行...\"+i);\n          }\n  \n      }\n  \n  }\n  ```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 5. yield()线程礼让\n\n- <font color=red>yield()</font>是多线程的礼让方法，它能让cpu重新调度，但不一定礼让成功\n\n- yield()执行结束后，线程进入就绪状态\n\n  ```java\n  // Thread.yield()礼让方法\n  public class ThreadDemo06_Yield implements Runnable {\n  \n      @Override\n      public void run() {\n          System.out.println(Thread.currentThread().getName()+\"开始执行~~~\");\n          Thread.yield(); // 礼让方法，让cpu重新调度\n          System.out.println(Thread.currentThread().getName()+\"结束执行~~~\");\n      }\n  \n      public static void main(String[] args) {\n  \n          new Thread(new ThreadDemo06_Yield(),\"a\").start();\n          new Thread(new ThreadDemo06_Yield(),\"b\").start();\n  \n          System.out.println(\"结束\");\n  \n          /*\n           可能结果：\n           a开始执行~~~\n           b开始执行~~~\n           b结束执行~~~\n           a结束执行~~~\n           结束\n           */\n  \n      }\n  \n  }\n  ```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 6. join()线程强制执行\n\n- <font color=red>join()</font>是多线程的强制执行的方法，它能强制执行调用join()方法的线程并阻塞其他线程，直到该线程执行结束\n\n  ```java\n  // join()强制执行方法\n  public class ThreadDemo07_Join implements Runnable {\n  \n      @Override\n      public void run() {\n          for (int i = 1; i <= 1000; i++) {\n              System.out.println(\"run()执行中~~~\"+i);\n          }\n      }\n  \n      public static void main(String[] args) throws InterruptedException {\n  \n          Thread thread = new Thread(new ThreadDemo07_Join());\n          thread.start();\n  \n          for (int i = 1; i <= 500; i++) {\n              System.out.println(\"main()执行中~~~\"+i);\n              if(i==100) {\n                  thread.join();  //  强制执行thread线程\n              }\n          }\n  \n      }\n  \n  }\n  ```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 7. getState()观察线程的状态\n\n- <font color=red>getState()</font>是多线程获取线程状态方法，其返回值为Thread.State类型\n\n- 在Java中，线程一共有<font color=red>初始(NEW)</font>、 <font color=red>运行(RUNNABLE)</font>、<font color=red>阻塞(BLOCKED)</font>、 <font color=red>等待(WAITING)</font>、<font color=red>超时等待(TIMED_WAITING)</font>和<font color=red>终止(TERMINATED)</font>六种状态：\n\n  - 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法\n  - 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。\n  - 阻塞(BLOCKED)：表示线程阻塞于锁。\n  - 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。\n  - 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。\n\n  ```java\n  // 观察线程的状态\n  public class ThreadDemo08_Status {\n  \n      public static void main(String[] args) throws InterruptedException {\n  \n          Thread.State state; //  线程的状态\n  \n          // 创建线程\n          Thread thread = new Thread(() -> {\n              System.out.println(\"正在执行~~~\");\n              try {\n                  Thread.sleep(1000); //  阻塞线程\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              System.out.println(\"执行结束~~~\");\n          });\n          state = thread.getState();\n          System.out.println(state);\n  \n          // 启动线程\n          thread.start();\n          state = thread.getState();\n          System.out.println(state);\n  \n          // 执行线程\n          while (thread.getState()!=Thread.State.TERMINATED) {\n              state = thread.getState();\n              System.out.println(state);\n              Thread.sleep(500);\n          }\n  \n          // 线程结束\n          state = thread.getState();\n          System.out.println(state);\n  \n          /*\n           结果：\n           NEW\n           RUNNABLE\n           RUNNABLE\n           正在执行~~~\n           TIMED_WAITING\n           执行结束~~~\n           TERMINATED\n           */\n  \n      }\n  \n  }\n  ```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 8. Priority线程的优先级\n\n- 在Java中，线程的执行由一个线程调度器根据线程的优先级来决定，优先级高的线程<font color=red>大概率</font>先执行\n\n- 线程的优先级范围为：1~10\n\n- 线程通过<font color=red>getPriority()</font>方法来获取线程的优先级，其返回值为int类型\n\n- 线程通过<font color=red>setPriority(xxx)</font>方法来获取线程的优先级，其参数值为int类型\n\n  ```java\n  // 线程的优先级\n  public class ThreadDemo09_Priority implements Runnable  {\n  \n      public static void main(String[] args) {\n  \n          Thread t1 = new Thread(new ThreadDemo09_Priority());\n          Thread t2 = new Thread(new ThreadDemo09_Priority());\n          Thread t3 = new Thread(new ThreadDemo09_Priority());\n          Thread t4 = new Thread(new ThreadDemo09_Priority());\n          Thread t5 = new Thread(new ThreadDemo09_Priority());\n  \n          // 先设置优先级再启动\n  \n          t1.start(); // 不设置优先级默认为5\n  \n          t2.setPriority(1);\n          t2.start();\n  \n          t3.setPriority(3);\n          t3.start();\n  \n          t4.setPriority(7);\n          t4.start();\n  \n          t5.setPriority(10);\n          t5.start();\n  \n          System.out.println(\"结束\");\n  \n          /*\n           结果：\n           Thread-4-->10\n           Thread-3-->7\n           Thread-0-->5\n           Thread-2-->3\n           Thread-1-->1\n           结束\n           */\n  \n      }\n  \n      @Override\n      public void run() {\n          System.out.println(Thread.currentThread().getName()+\"-->\"+Thread.currentThread().getPriority());\n      }\n  \n  }\n  ```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 9. daemon守护线程\n\n- 线程分为<font color=red>用户线程</font>和<font color=red>守护线程</font>\n\n- Java虚拟机必须等待用户线程执行完毕\n\n- Java虚拟机不用等待守护线程执行完毕\n\n- 通过<font color=red>setDaemon(true)</font>方法将线程设置为守护线程\n\n  ```java\n  // 守护线程\n  class God implements Runnable {\n  \n      @Override\n      public void run() {\n          while (true) {\n              System.out.println(\"上帝守护着你~~~\");\n          }\n      }\n  \n  }\n  \n  // 用户线程\n  class You implements Runnable {\n  \n      @Override\n      public void run() {\n          for (int i = 0; i < 36500; i++) {\n              System.out.println(\"你开心的活着~~~\");\n          }\n          System.out.println(\"再见，世界！\");\n      }\n  }\n  \n  public class ThreadDemo10_Daemon{\n  \n      public static void main(String[] args) {\n  \n          // 创建线程\n          Thread god = new Thread(new God());\n          Thread you = new Thread(new You());\n  \n          // 设置Daemon，成为守护线程\n          god.setDaemon(true);    // Daemon默认为false\n  \n          // 启动线程\n          god.start();\n          you.start();\n  \n      }\n  \n  }\n  ```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 10. Synchronized线程同步\n\n- <font color=red>synchronized</font>是线程同步的关键字(隐式的锁)，它能够让<font color=red>多个线程操作同一对象(并发)</font>时按顺序执行(按顺序获取锁)\n\n- 在Java中，<font color=red>一个对象对应一个锁</font>，获得锁的线程才能操作锁对应的对象\n\n- synchronized能修饰方法使方法成为同步方法，默认锁this对象\n\n- synchronized[(Object)]能修饰代码块使代码块成为同步方法块，Object为被锁的对象\n\n  ```java\n  // 椅子\n  class Chair implements Runnable {\n  \n      // 同步方法\n      @Override\n      public synchronized void run() {\n          for (int i = 0; i < 1000; i++) {\n              System.out.println(Thread.currentThread().getName()+\"正在椅子上休息~~~\"+i);\n          }\n          System.out.println(Thread.currentThread().getName()+\"休息结束！\");\n      }\n      \n      /*\n      \n       // 同步代码块\n       @Override\n       public void run() {\n       \t synchronized (this) {\n               for (int i = 0; i < 1000; i++) {\n                   System.out.println(Thread.currentThread().getName()+\"正在椅子上休息~~~\"+i);\n               }\n               System.out.println(Thread.currentThread().getName()+\"休息结束！\");\n           }\n       }\n       \n       */\n  \n  }\n  \n  // 线程同步机制synchronized，隐式的锁\n  public class ThreadDemo11_Synchronized {\n  \n      public static void main(String[] args) {\n  \n          // 创建启动线程\n          Chair chair = new Chair();\n          new Thread(chair,\"小明\").start();\n          new Thread(chair,\"小红\").start();\n  \n      }\n  \n  }\n  ```\n\n- 解决2.4中买票的并发问题\n\n  ```java\n  // 售票机\n  class TicketMachine2 implements Runnable {\n  \n      private int tickets;    // 剩余票数\n  \n      public TicketMachine2(int tickets) {\n          this.tickets = tickets;\n      }\n  \n      @Override\n      public void run() {\n  \n          while (this.tickets > 0) {\n              synchronized (this) {   // 同步块监视this对象\n                  System.out.println(Thread.currentThread().getName() + \"拿到了第\" + this.tickets-- + \"张票，剩余\" + this.tickets + \"张\");\n              }\n              try {\n                  Thread.sleep(200);  // 模拟延时\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n  \n      }\n  }\n  \n  public class BuyTicketDemo02_Synchronized {\n  \n      public static void main(String[] args) {\n  \n          // 创建售票机\n          TicketMachine2 tm = new TicketMachine2(10);\n  \n          new Thread(tm,\"小明\").start();\n          new Thread(tm,\"小红\").start();\n          new Thread(tm,\"小王\").start();\n  \n          /*\n           可能结果：\n           小明拿到了第10张票，剩余9张\n           小王拿到了第9张票，剩余8张\n           小红拿到了第8张票，剩余7张\n           小王拿到了第7张票，剩余6张\n           小明拿到了第6张票，剩余5张\n           小红拿到了第5张票，剩余4张\n           小明拿到了第4张票，剩余3张\n           小王拿到了第3张票，剩余2张\n           小红拿到了第2张票，剩余1张\n           小红拿到了第1张票，剩余0张\n           */\n  \n      }\n  \n  }\n  ```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 11. DeadLock死锁\n\n- 一个同步块需要<font color=red>同时</font>拥有“<font color=red>两把以上的锁</font>”时，可能造成死锁，例如：同一时间下，线程1拥有A锁，线程2拥有B锁。之后，线程1在拿着A锁的的情况下想获取B锁，线程2在拿着B锁的的情况下想获取A锁，这样就会造成死锁，程序会僵持不动。\n\n  ```java\n  // 第一根筷子\n  class FirstChopsticks {}\n  \n  // 第二根筷子\n  class SecondChopsticks {}\n  \n  // 吃饭\n  class EatMeals implements Runnable {\n  \n      private FirstChopsticks firstChopsticks;    // 第一根筷子\n      private SecondChopsticks secondChopsticks;  // 第二根筷子\n  \n      public EatMeals(FirstChopsticks firstChopsticks, SecondChopsticks secondChopsticks) {\n          this.firstChopsticks = firstChopsticks;\n          this.secondChopsticks = secondChopsticks;\n      }\n  \n      @Override\n      public void run() {\n          if(Thread.currentThread().getName().equals(\"小明\")) {\n              synchronized (this.firstChopsticks) {\n                  try {\n                      Thread.sleep(1000); // 保证同时进入线程\n                  } catch (InterruptedException e) {\n                      e.printStackTrace();\n                  }\n                  synchronized (this.secondChopsticks) {\n                      System.out.println(Thread.currentThread().getName()+\"开始吃饭\");\n                  }\n              }\n          }else {\n              synchronized (this.secondChopsticks) {\n                  try {\n                      Thread.sleep(1500); // 保证同时进入线程\n                  } catch (InterruptedException e) {\n                      e.printStackTrace();\n                  }\n                  synchronized (this.firstChopsticks) {\n                      System.out.println(Thread.currentThread().getName()+\"开始吃饭\");\n                  }\n              }\n          }\n          System.out.println(Thread.currentThread().getName()+\"吃完了~~~\");\n      }\n  \n  }\n  \n  // 死锁\n  public class ThreadDemo12_DeadLock {\n  \n      public static void main(String[] args) {\n  \n          // 创建开启线程\n          EatMeals eatMeals = new EatMeals(new FirstChopsticks(),new SecondChopsticks());\n          new Thread(eatMeals,\"小明\").start();\n          new Thread(eatMeals,\"小红\").start();\n  \n          /*\n           结果：\n           （产生死锁，程序僵持不停）\n           （解决方法：if(Thread.currentThread().getName().equals(\"小明\")) {\n                          synchronized (this.firstChopsticks) {\n                              try {\n                                  Thread.sleep(1000); // 保证同时进入线程\n                              } catch (InterruptedException e) {\n                                  e.printStackTrace();\n                              }\n                          }\n                          synchronized (this.secondChopsticks) {\n                              System.out.println(Thread.currentThread().getName()+\"开始吃饭\");\n                          }\n                      }else {\n                          synchronized (this.secondChopsticks) {\n                              try {\n                                  Thread.sleep(1500); // 保证同时进入线程\n                              } catch (InterruptedException e) {\n                                  e.printStackTrace();\n                              }\n                          }\n                          synchronized (this.firstChopsticks) {\n                              System.out.println(Thread.currentThread().getName()+\"开始吃饭\");\n                          }\n                      }）\n           */\n  \n      }\n  \n  }\n  ```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 12. Lock锁\n\n- 在Java中，可以显式的定义Lock锁，其实现类一般用ReentrantLock(可重入锁)\n\n  ```java\n  import java.util.concurrent.locks.ReentrantLock;\n  \n  // 椅子\n  class Chair2 implements Runnable {\n  \n      private final ReentrantLock lock = new ReentrantLock(); // 可重入锁\n  \n      @Override\n      public void run() {\n          lock.lock();    // 关锁\n          for (int i = 0; i < 1000; i++) {\n              System.out.println(Thread.currentThread().getName()+\"正在椅子上休息~~~\"+i);\n          }\n          System.out.println(Thread.currentThread().getName()+\"休息结束！\");\n          lock.unlock();  // 解锁\n      }\n  \n  }\n  \n  // Lock锁，显式的锁\n  public class ThreadDemo13_Lock {\n  \n      public static void main(String[] args) {\n  \n          // 创建启动线程\n          Chair2 chair2 = new Chair2();\n          new Thread(chair2,\"小明\").start();\n          new Thread(chair2,\"小红\").start();\n  \n      }\n  \n  }\n  ```\n\n&nbsp;\n\n---\n\n&nbsp;\n\n## 13. 线程池\n\n- 线程池是多线程处理的一种形式，它在进程开始的时候就创建一定数量的线程，并将这些线程添加到线程池中等待工作\n\n- 线程池具有以下优点：\n\n  - 提高响应速度：用现有线程服务请求比等待创建一个线程更快\n  - 降低资源消耗：重复利用现有的线程，不需要每次都创建浪费资源\n  - 便于线程管理：\n    - 自定义核心池的大小：corePoolSize\n    - 自定义最大线程数：maxmumPoolSize\n    - 自定义线程的持续时间：keepAliveTime\n\n- 创建线程池及服务：ExecutorService ser = Executors.newFixedThreadPool(线程数);\n\n- 执行任务：\n\n  - void execute(Runnable command)：执行任务/命令，没有返回值，一般用于执行Runnable\n  - \\<T\\> Future\\<T\\> submit(Callable\\<T\\> task)：执行任务，有返回值，一般用于执行Callable\n\n- 关闭连接池：void shutdown();\n\n  ```java\n  import java.util.concurrent.ExecutorService;\n  import java.util.concurrent.Executors;\n  \n  class SayName implements Runnable {\n  \n      @Override\n      public void run() {\n          System.out.println(Thread.currentThread().getName());\n      }\n  \n  }\n  \n  // 线程池\n  public class ThreadDemo14_Pool {\n  \n      public static void main(String[] args) {\n  \n          // 创建服务、线程池\n          ExecutorService ser = Executors.newFixedThreadPool(5);\n  \n          // 执行线程\n          SayName sayName = new SayName();\n  \n          ser.execute(sayName);\n          ser.execute(sayName);\n  \n          ser.execute(new SayName());\n          ser.execute(new SayName());\n  \n          // 关闭连接\n          ser.shutdown();\n  \n          /*\n           可能结果：\n           pool-1-thread-1\n           pool-1-thread-3\n           pool-1-thread-2\n           pool-1-thread-4\n           */\n  \n      }\n  \n  }\n  ```","categoryId":"1","categoryName":"技术记录","tags":[{"id":"2","name":"Java"}],"views":1,"topping":false,"status":1,"createTime":"2022-10-24 20:49:57"}}